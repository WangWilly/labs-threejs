<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Morphing Resume - Yuli W.</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            color: #ffffff;
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(30, 30, 50, 0.8);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            border: 1px solid #445;
            z-index: 10; /* Ensure controls are above canvas */
        }
        #shape-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(10, 10, 30, 0.8);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            border: 1px solid #334;
            white-space: nowrap;
            z-index: 10; /* Ensure info is above canvas */
        }
        /* Contact Card Styling */
        #contact-card {
            position: fixed;
            top: 10px;
            left: 10px;
            background-color: rgba(10, 10, 30, 0.85);
            border-radius: 10px;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            border: 1px solid #445;
            backdrop-filter: blur(5px);
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }
        #contact-card .name {
            font-size: 18px;
            font-weight: bold;
            color: white;
            font-family: 'Courier New', monospace;
        }
        #contact-card .social-icons {
            display: flex;
            gap: 12px;
        }
        #contact-card .social-icons a {
            color: #8a2be2;
            transition: color 0.3s, transform 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #contact-card .social-icons a:hover {
            color: #4169e1;
            transform: scale(1.2);
        }
    </style>
</head>
<body>

    <div id="shape-info">Shape: Sphere (Auto-changing)</div>

    <!-- Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let particles, particlesGeometry;
        let stars, starsGeometry;
        let targetPositions = {};
        let currentShapeIndex = 0;
        let isMorphing = false;
        let morphProgress = 0;
        const morphDuration = 2.0; // seconds
        const particleCount = 15000;
        let shapes = ['Sphere', 'Cube', 'Pyramid', 'Torus', 'Galaxy', 'Wave'];
        const shapeInfoElement = document.getElementById('shape-info');
        let currentColorScheme = 2; // Set to color-2 scheme
        const clock = new THREE.Clock();
        
        // New variables for automatic shape changes and mouse following
        let autoChangeInterval = 15; // seconds between automatic shape changes - increased for reading time
        let lastAutoChangeTime = 0; // track when we last auto-changed
        let mousePosition = new THREE.Vector2(0, 0); // to track mouse position
        let targetRotation = new THREE.Euler(0, 0, 0); // target rotation for shape
        let currentRotation = new THREE.Euler(0, 0, 0); // current rotation
        let rotationSpeed = 2.0; // how quickly the shape rotates to follow mouse
        let autoChangeEnabled = true; // toggle for auto-changing
        
        // Resume content configuration
        const resumeSections = [
            {
                title: "EDUCATION",
                content: [
                    "1. The Ohio State University, Columbus, Ohio",
                    "(Aug. 2024 — Jan. 2025)",
                    "- Master of Engineering in Computer Science Engineering (CSE)",
                    "",
                    "2. National Taiwan University, Taipei, Taiwan",
                    "(Sept. 2019 — June 2021)",
                    "- Master of Science in Computer Science and Information Engineering (CSIE)",
                    "- Master's Thesis: Singing Voice Separation Using U-Net and Its Compressed Version"
                ]
            },
            {
                title: "SKILLS",
                content: [
                    "1. Research Interests:",
                    "Web3, Blockchain, Music Signal Analysis, Machine Learning, AI",
                    "2. Programming:",
                    "Solidity, Go, Rust, Java, TS/JS, Python, Cpp, SQL, Bash, Web Frameworks, CI/CD",
                    "3. Software:",
                    "Linux, Git, PostgreSQL, MongoDB, Redis, Docker, K8s, AWS, Azure, GCP",
                ]
            },
            {
                title: "PERSONAL PROJECTS",
                content: [
                    "1. Client-side Solana Trade Bot, Web3 project",
                    "(Jan. 2025 — Current)",
                    "- Designed an automated trading system to prevent abusing private keys",
                    "- Focused on copy-trading and snipping tokens on Solana with user defined strategies",
                    "- Analyzed event logs through websocket for accurate amount and triggering copy trades",
                    "- Adopted Jupiter APIs for DEX routes optimizing and Jito nodes for higher tx sending speed",
                    "",
                    "2. Dounty, Web3 project",
                    "(Jan. 2025 — Current)",
                    "- A tool to incentivize developers to contribute to open source projects with bounties",
                    "- Deployed Solana smart contracts to collect solana native token as bounties from donors",
                    "- Designed quorum scheme through Solana smart contract for bounty issue and NFT rewards",
                    "",
                    "3. EVM/oracle monorepo, Web3 project",
                    "(Apr. 2025 — Current)",
                    "- A Typescript monorepo template project for friendly deployment of Solidity project",
                    "- Deployed EVM contracts allow users to send and retrieve messages through Oracle",
                    "",
                    "4. Crypto price CLI display module, Trade project",
                    "(May 2025)",
                    "- A tool displays Bitcoin price data in terminal as ASCII chart with automatic refresh",
                    "- Adopted CCXT for CEXes (Binance, OKX) flexible API support with little development"
                ]
            },
            {
                title: "WORK EXPERIENCE",
                content: [
                    "1. Mastertones Co., Ltd., Taipei (remote), Taiwan",
                    "(July. 2024 — Dec. 2024)",
                    "- Software Engineer, Application | Part-time",
                    "- Designed and implemented APIs for AI Interactive Experience system using NestJS",
                    "- Integrated AI model with RESTful APIs for the TTS system and dockerized for AWS",
                    "",
                    "2. Yating Intelligence Co., Ltd., Taipei, Taiwan",
                    "May 2023 — July. 2024",
                    "- Software Engineer, Application Service",
                    "- Developed APIs using Go, NestJS, and PostgreSQL for web/mobile app features",
                    "- Managed microservice systems on GCP using RestfulAPI, GRPC and Pub/Sub",
                    "- Designed a post recommendation system, raised retention rate by 40%",
                    "- Built features for TTS, ASR, and virtual talker services",
                    "",
                    "3. ASUSTeK Computer Inc., Taipei, Taiwan",
                    "Mar. 2022 — Mar. 2023",
                    "- Software Engineer, Asus Intelligent Cloud Service",
                    "- Adapted an automated E2E testing system with Python and Selenium",
                    "- Designed natural language commands, reducing QA development time by 50%",
                    "- Improved response time by 30% through data flow and MongoDB optimization" 
                ]
            }
        ];

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 4;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Orbit Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Enable smooth damping (inertia)
            controls.dampingFactor = 0.05; // Adjust damping intensity
            
            // Creating text overlay for resume content
            createResumeOverlay();
            
            // Update shapes to use resume sections
            shapes = ['Education', 'Skills', 'Projects', 'Experience'];
            
            // Particles Geometry
            particlesGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const startPositions = new Float32Array(particleCount * 3); // For morphing
            const randomFactors = new Float32Array(particleCount); // For galaxy/wave variation

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 5;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 5;
                randomFactors[i] = Math.random();
            }

            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particlesGeometry.setAttribute('startPosition', new THREE.BufferAttribute(startPositions, 3));
            particlesGeometry.setAttribute('randomFactor', new THREE.BufferAttribute(randomFactors, 1));

            // Particles Material
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.02,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            // Particles Object
            particles = new THREE.Points(particlesGeometry, particleMaterial);
            scene.add(particles);

            // Background Stars
            starsGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            const starColors = [];
            const starCount = 5000;
            const starColor = new THREE.Color(0.8, 0.8, 0.9);

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(200);
                const y = THREE.MathUtils.randFloatSpread(200);
                const z = THREE.MathUtils.randFloatSpread(200);
                const d = Math.sqrt(x*x + y*y + z*z);
                 if (d < 50) {
                    const scale = 50 / d;
                    starPositions.push(x*scale, y*scale, z*scale);
                 } else {
                    starPositions.push(x, y, z);
                 }
                starColors.push(starColor.r, starColor.g, starColor.b);
            }
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));
            const starsMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.6
             });
            stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);

            // Pre-calculate all target positions
            generateShapePositions();
            
            // Set initial shape to Education
            currentShapeIndex = 0;
            setShape(currentShapeIndex, true);
            applyColorScheme(currentColorScheme);
            updateResumeContent(currentShapeIndex);
            
            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            shapeInfoElement.addEventListener('click', toggleAutoChange);
            
            // Add keyboard navigation for resume sections
            window.addEventListener('keydown', handleKeyNavigation);
            
            updateShapeInfo();
            
            // Start animation loop
            animate();
        }
        
        // Mouse movement handler - Adding missing function definition
        function onMouseMove(event) {
            // Calculate normalized device coordinates (-1 to +1) for mouse position
            mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
            mousePosition.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Map mouse position to rotation angles - X position affects Y rotation
            // and Y position affects X rotation (inverted)
            targetRotation.y = mousePosition.x * Math.PI * 0.5; // 90 degrees max rotation
            targetRotation.x = -mousePosition.y * Math.PI * 0.3; // 60 degrees max rotation
        }
        
        // Create HTML overlay for resume content
        function createResumeOverlay() {
            const overlay = document.createElement('div');
            overlay.id = 'resume-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '80px';
            overlay.style.left = '50%';  // Center horizontally
            overlay.style.transform = 'translateX(-50%)';  // Center alignment
            overlay.style.width = '600px';  // Wider for better readability
            overlay.style.maxHeight = '80vh';
            overlay.style.overflowY = 'auto';
            overlay.style.backgroundColor = 'rgba(10, 10, 30, 0.85)';
            overlay.style.padding = '25px';  // More padding
            overlay.style.borderRadius = '10px';
            overlay.style.color = 'white';
            overlay.style.fontFamily = "'Courier New', monospace";
            overlay.style.fontSize = '18px';  // Bigger font
            overlay.style.zIndex = '100';
            overlay.style.border = '1px solid #445';
            overlay.style.backdropFilter = 'blur(5px)';
            overlay.style.boxShadow = '0 4px 20px rgba(0,0,0,0.5)';
            document.body.appendChild(overlay);
        }
        
        // Update resume content in the overlay
        function updateResumeContent(sectionIndex) {
            const overlay = document.getElementById('resume-overlay');
            const section = resumeSections[sectionIndex];
            
            let html = `<h2 style="color:#8a2be2;margin-top:0;border-bottom:1px solid #4169e1;padding-bottom:10px">
                        ${section.title}</h2>`;
                        
            html += '<div style="line-height:1.5">';
            section.content.forEach(line => {
                if (line === "") {
                    html += '<br>';
                } else if (line.startsWith('-')) {
                    html += `<div style="padding-left:15px;color:#bbd">${line}</div>`;
                } else if (line.match(/^\d+\./)) {
                    html += `<div style="margin-top:12px;color:#3cb371;font-weight:bold">${line}</div>`;
                } else {
                    html += `<div>${line}</div>`;
                }
            });
            html += '</div>';
            
            // Add navigation hint
            html += `<div style="margin-top:20px;font-size:12px;color:#aaa;text-align:center">
                    Press arrow keys or click section title to navigate • Section ${sectionIndex + 1} of 4</div>`;
            
            overlay.innerHTML = html;
        }
        
        // Handle keyboard navigation between sections
        function handleKeyNavigation(event) {
            if (isMorphing) return;
            
            if (event.key === 'ArrowRight' || event.key === 'ArrowDown' || event.key === 'j' || event.key === 'l') {
                // Next section
                lastAutoChangeTime = clock.getElapsedTime();
                goToSection((currentShapeIndex + 1) % shapes.length);
            } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp' || event.key === 'k' || event.key === 'h') {
                // Previous section
                lastAutoChangeTime = clock.getElapsedTime();
                goToSection((currentShapeIndex - 1 + shapes.length) % shapes.length);
            }
        }
        
        // Go to a specific section
        function goToSection(index) {
            if (isMorphing || index === currentShapeIndex) return;
            
            // Store current position for morphing
            const currentPositions = particlesGeometry.attributes.position.array;
            const startPositionsAttribute = particlesGeometry.attributes.startPosition;
            for(let i=0; i < currentPositions.length; i++) {
                startPositionsAttribute.array[i] = currentPositions[i];
            }
            startPositionsAttribute.needsUpdate = true;
            
            // Set the target section
            isMorphing = true;
            morphProgress = 0;
            currentShapeIndex = index;
            shapeInfoElement.textContent = 'Morphing...';
            
            // Update resume content immediately for better UX
            updateResumeContent(currentShapeIndex);
        }

        // Toggle auto-change feature
        function toggleAutoChange() {
            autoChangeEnabled = !autoChangeEnabled;
            updateShapeInfo();
        }
        
        // Update shape info text based on current state
        function updateShapeInfo() {
            const currentShape = shapes[currentShapeIndex];
            if (autoChangeEnabled) {
                shapeInfoElement.textContent = `${resumeSections[currentShapeIndex].title} (Auto-changing)`;
            } else {
                shapeInfoElement.textContent = `${resumeSections[currentShapeIndex].title} (Click to toggle auto-change)`;
            }
        }

        // --- Shape Generation ---
        function generateShapePositions() {
            targetPositions['Education'] = generateEducationShape();
            targetPositions['Skills'] = generateSkillsShape();
            targetPositions['Projects'] = generateProjectsShape();
            targetPositions['Experience'] = generateExperienceShape();
        }
        
        // Generate a shape representing Education (Modified Sphere)
        function generateEducationShape() {
            const positions = new Float32Array(particleCount * 3);
            const radius = 1.5;
            const randomFactors = particlesGeometry.attributes.randomFactor.array;
            
            // Create two connected spheres representing two degrees
            for (let i = 0; i < particleCount; i++) {
                const idx = i + 0.5;
                // Determine which sphere this particle belongs to
                const inFirstSphere = i < particleCount * 0.6;
                const phi = Math.acos(1 - 2 * (idx % (particleCount * 0.6)) / (particleCount * 0.6));
                const theta = Math.PI * (1 + Math.sqrt(5)) * idx;
                
                // Base position on sphere
                let x = radius * Math.sin(phi) * Math.cos(theta);
                let y = radius * Math.sin(phi) * Math.sin(theta);
                let z = radius * Math.cos(phi);
                
                // Add perturbation
                const perturbation = (randomFactors[i] - 0.5) * 0.1;
                x += perturbation * x / radius;
                y += perturbation * y / radius;
                z += perturbation * z / radius;
                
                // Offset second sphere
                if (!inFirstSphere) {
                    x *= 0.7;
                    y *= 0.7;
                    z = z - 1.5;
                }
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            return positions;
        }
        
        // Generate a shape representing Skills (Spiral structure)
        function generateSkillsShape() {
            const positions = new Float32Array(particleCount * 3);
            const randomFactors = particlesGeometry.attributes.randomFactor.array;
            
            // Create branching structure for different skill categories
            for (let i = 0; i < particleCount; i++) {
                const category = Math.floor(randomFactors[i] * 3); // 3 skill categories
                const t = (i % (particleCount/3)) / (particleCount/3) * Math.PI * 6; // Parameter along spiral
                
                let x, y, z;
                const radius = 0.8 + t * 0.05;
                
                // Different spiral for each category
                switch(category) {
                    case 0: // Research interests
                        x = radius * Math.cos(t);
                        y = t * 0.1;
                        z = radius * Math.sin(t);
                        break;
                    case 1: // Programming skills
                        x = radius * Math.cos(t + Math.PI * 2/3);
                        y = t * 0.1 - 0.5;
                        z = radius * Math.sin(t + Math.PI * 2/3);
                        break;
                    case 2: // Software skills
                        x = radius * Math.cos(t + Math.PI * 4/3);
                        y = t * 0.1 - 1.0;
                        z = radius * Math.sin(t + Math.PI * 4/3);
                        break;
                }
                
                // Add some noise
                const noise = (randomFactors[i] - 0.5) * 0.1;
                x += noise;
                z += noise;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            return positions;
        }
        
        // Generate a shape representing Projects (4 interconnected nodes)
        function generateProjectsShape() {
            const positions = new Float32Array(particleCount * 3);
            const randomFactors = particlesGeometry.attributes.randomFactor.array;
            
            // Create 4 clusters for 4 projects with connecting paths
            for (let i = 0; i < particleCount; i++) {
                const projectIndex = Math.floor(randomFactors[i] * 4); // 4 projects
                const isConnector = randomFactors[i] > 0.85; // Some particles form connectors
                
                let x, y, z;
                
                if (isConnector) {
                    // Create connecting paths between project nodes
                    const fromProject = Math.floor(randomFactors[i] * 3);
                    const toProject = fromProject + 1;
                    
                    // Get positions of the two projects
                    const fromPos = getProjectPosition(fromProject);
                    const toPos = getProjectPosition(toProject);
                    
                    // Interpolate along the path with some randomness
                    const t = (randomFactors[(i*13) % particleCount]);
                    x = fromPos.x * (1-t) + toPos.x * t;
                    y = fromPos.y * (1-t) + toPos.y * t;
                    z = fromPos.z * (1-t) + toPos.z * t;
                    
                    // Add arc to path
                    y += Math.sin(t * Math.PI) * 0.5;
                    
                    // Add some noise
                    const noise = (randomFactors[(i*17) % particleCount] - 0.5) * 0.2;
                    x += noise;
                    z += noise;
                } else {
                    // Create project nodes
                    const pos = getProjectPosition(projectIndex);
                    const phi = Math.acos(1 - 2 * randomFactors[(i*11) % particleCount]);
                    const theta = 2 * Math.PI * randomFactors[(i*7) % particleCount];
                    
                    const radius = 0.4;
                    x = pos.x + radius * Math.sin(phi) * Math.cos(theta) * 0.6;
                    y = pos.y + radius * Math.sin(phi) * Math.sin(theta) * 0.6;
                    z = pos.z + radius * Math.cos(phi) * 0.6;
                }
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            return positions;
        }
        
        // Helper function to get project node positions
        function getProjectPosition(index) {
            const positions = [
                { x: -1.2, y: 0.8, z: 0.5 },   // Project 1
                { x: 1.2, y: 0.8, z: 0.5 },    // Project 2
                { x: -1.2, y: -0.8, z: 0.5 },  // Project 3
                { x: 1.2, y: -0.8, z: 0.5 }    // Project 4
            ];
            return positions[index];
        }
        
        // Generate a shape representing Work Experience (Timeline structure)
        function generateExperienceShape() {
            const positions = new Float32Array(particleCount * 3);
            const randomFactors = particlesGeometry.attributes.randomFactor.array;
            
            // Create a timeline with 3 job nodes
            for (let i = 0; i < particleCount; i++) {
                // Determine which job this particle belongs to
                const jobIndex = Math.floor(randomFactors[i] * 3);
                const isTimeline = randomFactors[i] > 0.9; // Some particles form the timeline
                
                let x, y, z;
                
                if (isTimeline) {
                    // Create timeline backbone
                    x = (randomFactors[(i*23) % particleCount] - 0.5) * 3;
                    y = 0;
                    z = -0.5;
                    
                    // Add some waviness
                    y += Math.sin(x * 4) * 0.05;
                } else {
                    // Create job nodes expanded vertically
                    const jobPosition = -1.5 + jobIndex * 1.5; // Space jobs along x-axis
                    const jobSize = 0.4 + (3-jobIndex) * 0.15; // Earlier jobs are slightly larger (more details)
                    
                    // Base position within job node
                    const phi = Math.acos(1 - 2 * randomFactors[(i*31) % particleCount]);
                    const theta = 2 * Math.PI * randomFactors[(i*41) % particleCount];
                    
                    const nodeRadius = jobSize;
                    
                    // Create vertically expanded cylinder
                    const heightFactor = 1.8;
                    x = jobPosition + nodeRadius * Math.sin(phi) * Math.cos(theta) * 0.6;
                    y = nodeRadius * heightFactor * Math.sin(phi) * Math.sin(theta);
                    z = nodeRadius * Math.cos(phi) * 0.6;
                    
                    // Flatten slightly (more horizontal spread)
                    x *= 1.2;
                    z *= 0.8;
                }
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }
            return positions;
        }

        // --- Morphing ---
        function triggerMorph() {
            // Prevent triggering another morph while one is in progress
            if (isMorphing) return;

            isMorphing = true;
            morphProgress = 0;

            // Store starting positions FROM the current 'position' attribute
            // This ensures we start from the exact end state of the previous shape
            const currentPositions = particlesGeometry.attributes.position.array;
            const startPositionsAttribute = particlesGeometry.attributes.startPosition;
            for(let i=0; i < currentPositions.length; i++) {
                startPositionsAttribute.array[i] = currentPositions[i];
            }
            startPositionsAttribute.needsUpdate = true; // Crucial: tell Three.js the buffer changed

            // Increment index for the NEXT shape
            currentShapeIndex = (currentShapeIndex + 1) % shapes.length;

            // Update UI immediately
            shapeInfoElement.textContent = 'Morphing...';
        }

        function updateMorph(deltaTime) {
            if (!isMorphing) return;

            // Ensure morphDuration is positive
            if (morphDuration <= 0) {
                console.error("morphDuration must be positive!");
                isMorphing = false;
                shapeInfoElement.textContent = `Error: Invalid morph duration`;
                return;
            }

            morphProgress += deltaTime;
            // 1. Calculate the raw progress based on time elapsed
            let rawProgressRatio = morphProgress / morphDuration;

            // 2. Clamp the RAW progress ratio between 0 and 1
            // This value will determine if the animation time is complete
            const clampedRawProgressRatio = Math.max(0.0, Math.min(rawProgressRatio, 1.0));

            // 3. Apply easing function ONLY to the clamped ratio for interpolation
            let easedProgressRatio = clampedRawProgressRatio < 0.5 ? 2 * clampedRawProgressRatio * clampedRawProgressRatio : 1 - Math.pow(-2 * clampedRawProgressRatio + 2, 2) / 2;
            // Optional: Clamp eased value too, just to be safe (though shouldn't be needed now)
            easedProgressRatio = Math.max(0.0, Math.min(easedProgressRatio, 1.0));

            const currentPosAttr = particlesGeometry.attributes.position;
            const startPositions = particlesGeometry.attributes.startPosition.array;
            const targetShapeName = shapes[currentShapeIndex];
            const target = targetPositions[targetShapeName];

            // --- Crucial Checks ---
            if (!target) {
                console.error(`Target positions for shape "${targetShapeName}" (index ${currentShapeIndex}) not found!`);
                isMorphing = false;
                shapeInfoElement.textContent = `Error: Target shape data missing`;
                return;
            }
            if (target.length !== currentPosAttr.count * 3 || startPositions.length !== currentPosAttr.count * 3) {
                 console.error(`Array length mismatch! Morphing to "${targetShapeName}".`);
                 isMorphing = false;
                 shapeInfoElement.textContent = `Error: Shape data size mismatch`;
                 return;
            }
            // --- End Crucial Checks ---

            // 4. Interpolate using the EASED progress ratio
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const startX = startPositions[i3], startY = startPositions[i3 + 1], startZ = startPositions[i3 + 2];
                const targetX = target[i3], targetY = target[i3 + 1], targetZ = target[i3 + 2];

                currentPosAttr.array[i3] = THREE.MathUtils.lerp(startX, targetX, easedProgressRatio);
                currentPosAttr.array[i3 + 1] = THREE.MathUtils.lerp(startY, targetY, easedProgressRatio);
                currentPosAttr.array[i3 + 2] = THREE.MathUtils.lerp(startZ, targetZ, easedProgressRatio);
            }
            currentPosAttr.needsUpdate = true;

            // Apply color-2 scheme while morphing
            applyColorScheme(currentColorScheme);

            // 5. Check for completion using the CLAMPED RAW progress ratio
            if (clampedRawProgressRatio >= 1.0) {
                isMorphing = false; // Reset flag FIRST
                morphProgress = 0;  // Reset progress time

                try {
                    // Snap precisely to the final target position
                    setShape(currentShapeIndex, false); // updateText = false
                } catch (e) {
                    console.error("Error during setShape in morph completion:", e);
                }

                // Update UI elements AFTER resetting isMorphing flag
                updateShapeInfo();
                updateResumeContent(currentShapeIndex); // Update resume section

                // Apply color-2 scheme precisely
                try {
                    applyColorScheme(currentColorScheme);
                } catch(e) {
                    console.error("Error during final applyColorScheme:", e);
                }
            }
        }

        function setShape(index, updateText = false) {
            const targetShapeName = shapes[index];
            const target = targetPositions[targetShapeName];
            if (!target) {
                console.error(`Target positions for shape "${targetShapeName}" (index ${index}) not found in setShape!`);
                return;
            }
            const positions = particlesGeometry.attributes.position;
             // Use positions.count which is reliable number of vertices
            if (positions.count * 3 !== target.length) {
                 console.error(`Position buffer count (${positions.count*3}) does not match target length (${target.length}) in setShape for "${targetShapeName}"!`);
                 return;
             }

            for (let i = 0; i < target.length; i++) {
                positions.array[i] = target[i];
            }
            positions.needsUpdate = true; // Tell Three.js the buffer changed

            // Update info text only if requested AND not currently morphing
            if (updateText && !isMorphing) {
               updateShapeInfo();
            }
            // Recompute bounding box after changing shape significantly
            particlesGeometry.computeBoundingBox();
        }

        // --- Coloring ---
        function applyColorScheme(scheme) {
            // Always use color-2 scheme (purple/blue/green gradient)
            scheme = 2;
            
            const positions = particlesGeometry.attributes.position.array;
            const colors = particlesGeometry.attributes.color.array;
            const color = new THREE.Color();

            // Ensure bounding box is computed and up-to-date
            if (!particlesGeometry.boundingBox) {
                 particlesGeometry.computeBoundingBox();
            }
            let bounds = particlesGeometry.boundingBox;
             // Handle cases where bounding box might be invalid initially
             if (!bounds || !bounds.min || !bounds.max || bounds.isEmpty()) {
                console.warn("Invalid bounding box in applyColorScheme, using defaults.");
                 // Provide default fallbacks if bounds are bad
                 bounds = { 
                     min: new THREE.Vector3(-1,-1,-1), 
                     max: new THREE.Vector3(1,1,1),
                     getCenter: function(vec) { vec.set(0,0,0); return vec; }
                 };
             }

            const minX = bounds.min.x;
            const maxX = bounds.max.x;
            const rangeX = Math.max(0.001, maxX - minX);

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                // Bounds check for safety
                if (i3 + 2 >= positions.length || i3 + 2 >= colors.length) continue;

                const x = positions[i3];
                
                // Purple/Blue/Green gradient based on X
                const ratioX2 = THREE.MathUtils.clamp((x - minX) / rangeX, 0, 1);
                color.setHSL(0.75 - ratioX2 * 0.3, 0.8, 0.5);

                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            particlesGeometry.attributes.color.needsUpdate = true;
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();

            // Check for auto shape change if enabled and not currently morphing
            if (autoChangeEnabled && !isMorphing && 
                (elapsedTime - lastAutoChangeTime > autoChangeInterval)) {
                lastAutoChangeTime = elapsedTime;
                goToSection((currentShapeIndex + 1) % shapes.length);
            }

            // Update morphing state
            updateMorph(deltaTime);

            // Smooth rotation toward mouse position
            if (!isMorphing) { // Only rotate when not morphing to avoid visual conflicts
                currentRotation.x += (targetRotation.x - currentRotation.x) * rotationSpeed * deltaTime;
                currentRotation.y += (targetRotation.y - currentRotation.y) * rotationSpeed * deltaTime;
                particles.rotation.x = currentRotation.x;
                particles.rotation.y = currentRotation.y;
            }
            
            // Update OrbitControls (handles camera rotation/zoom/pan)
            controls.update(); // Must be called if controls.enableDamping is true

            // Optional: Slow rotation for background stars
            if (stars) {
                stars.rotation.y += deltaTime * 0.005;
            }

            renderer.render(scene, camera);
        }

        // --- Resize Handling ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Start ---
        init();
    </script>

    <!-- Contact Info Card -->
    <div id="contact-card">
        <div class="name">Yuli W.</div>
        <div class="social-icons">
            <a href="mailto:angles.anodes.0v@icloud.com" title="Email">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path>
                    <polyline points="22,6 12,13 2,6"></polyline>
                </svg>
            </a>
            <a href="https://www.linkedin.com/in/willywangkaa" target="_blank" title="LinkedIn">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path>
                    <rect x="2" y="9" width="4" height="12"></rect>
                    <circle cx="4" cy="4" r="2"></circle>
                </svg>
            </a>
            <a href="https://github.com/WangWilly" target="_blank" title="GitHub">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
                </svg>
            </a>
        </div>
    </div>

</body>
</html>
